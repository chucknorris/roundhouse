<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="__SOLUTION_NAME_WITHOUT_SLN_EXTENSION__" Platform="DotNet">
  <OutputDir KeepHistoric="True" KeepXmlFiles="True" ViewReport="True">.\build_output\build_artifacts\ndepend</OutputDir>
  <Assemblies>
    <Name>PROJECTASSEMBLIESGOHERE</Name>
  </Assemblies>
  <FrameworkAssemblies>
    <Name>Castle.Core</Name>
    <Name>Castle.Components.Validator</Name>
    <Name>Castle.DynamicProxy2</Name>
    <Name>Castle.DynamicProxy</Name>
    <Name>Castle.Facilities.NHibernateIntegration</Name>
    <Name>Castle.MicroKernel</Name>
    <Name>Castle.Windsor</Name>
    <Name>FileHelpers</Name>
    <Name>Iesi.Collections</Name>
    <Name>log4net</Name>
    <Name>MassTransit.ServiceBus</Name>
    <Name>MassTransit.ServiceBus.MSMQ</Name>
    <Name>MassTransit.SubscriptionStorage</Name>
    <Name>MassTransit.WindsorIntegration</Name>
    <Name>Microsoft.ReportViewer.Common</Name>
    <Name>Microsoft.ReportViewer.ProcessingObjectModel</Name>
    <Name>Microsoft.ReportViewer.WebForms</Name>
    <Name>Microsoft.SqlServer.BatchParser</Name>
    <Name>Microsoft.SqlServer.Replication</Name>
    <Name>MbUnit.Framework</Name>
    <Name>mscorlib</Name>
    <Name>NHibernate</Name>
    <Name>Rhino.Mocks</Name>
    <Name>System</Name>
    <Name>System.configuration</Name>
    <Name>System.configuration.Install</Name>
    <Name>System.Core</Name>
    <Name>System.Data</Name>
    <Name>System.Deployment</Name>
    <Name>System.Drawing</Name>
    <Name>System.EnterpriseServices</Name>
    <Name>System.ServiceModel</Name>
    <Name>System.ServiceProcess</Name>
    <Name>System.Web</Name>
    <Name>System.Web.Mobile</Name>
    <Name>System.Web.Services</Name>
    <Name>System.Xml</Name>
  </FrameworkAssemblies>
  <Dirs>
    <Dir>C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727</Dir>
    <Dir>C:\WINDOWS\Microsoft.NET\Framework\v3.0</Dir>
    <Dir>C:\WINDOWS\Microsoft.NET\Framework\v3.5</Dir>
    <Dir>.\build_output</Dir>
  </Dirs>
  <Report XslPath="">
    <Section Enabled="True">Application Metrics</Section>
    <Section Enabled="True">Assemblies Metrics</Section>
    <Section Enabled="True">VisualNDepend View</Section>
    <Section Enabled="True">Assemblies Abstractness vs. Instability</Section>
    <Section Enabled="True">Assemblies Dependencies</Section>
    <Section Enabled="True">Assemblies Dependencies Diagram</Section>
    <Section Enabled="True">Assemblies build order</Section>
    <Section Enabled="True">NDepend information and warnings</Section>
    <Section Enabled="True">CQL Queries and Constraints</Section>
    <Section Enabled="True">Types Metrics</Section>
    <Section Enabled="False">Types Dependencies</Section>
  </Report>
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="MostRecentBuildAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" />
  <CoverageFiles UncoverableAttribute="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <CQLQueries>
    <CQLGroup Name="Code Quality" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Quick summary of methods to refactor&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS /*OUT OF "YourGeneratedCode" */ WHERE \r\n\r\n                                           // Metrics' definitions\r\n     (  NbLinesOfCode &gt; 30 OR              // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode\r\n        NbILInstructions &gt; 200 OR          // http://www.ndepend.com/Metrics.aspx#NbILInstructions\r\n        CyclomaticComplexity &gt; 20 OR       // http://www.ndepend.com/Metrics.aspx#CC\r\n        ILCyclomaticComplexity &gt; 50 OR     // http://www.ndepend.com/Metrics.aspx#ILCC\r\n        ILNestingDepth &gt; 4 OR              // http://www.ndepend.com/Metrics.aspx#ILNestingDepth\r\n        NbParameters &gt; 5 OR                // http://www.ndepend.com/Metrics.aspx#NbParameters\r\n        NbVariables &gt; 8 OR                 // http://www.ndepend.com/Metrics.aspx#NbVariables\r\n        NbOverloads &gt; 6 )                  // http://www.ndepend.com/Metrics.aspx#NbOverloads\r\n     AND \r\n\r\n     // Here are some ways to avoid taking account of generated methods.\r\n     !( NameIs "InitializeComponent()" OR\r\n        // NDepend.CQL.GeneratedAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n        // You can define your own attribute to mark "Generated".\r\n        HasAttribute "OPTIONAL:NDepend.CQL.GeneratedAttribute") </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too big (NbLinesOfCode)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbLinesOfCode &gt; 30 ORDER BY NbLinesOfCode DESC\r\n// METHODS WHERE NbLinesOfCode &gt; 30 are extremely complex and \r\n// should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the NbLinesOfCode metric here http://www.ndepend.com/Metrics.aspx#NbLinesOfCode</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too big (NbILInstructions)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbILInstructions &gt; 200 ORDER BY NbILInstructions DESC\r\n// METHODS WHERE NbILInstructions &gt; 200 are extremely complex and \r\n// should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the NbILInstructions metric here http://www.ndepend.com/Metrics.aspx#NbILInstructions</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (CyclomaticComplexity)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE CyclomaticComplexity &gt; 20 ORDER BY CyclomaticComplexity DESC\r\n// METHODS WHERE CyclomaticComplexity &gt; 15 are hard to understand and maintain.\r\n// METHODS WHERE CyclomaticComplexity &gt; 30 are extremely complex and should be split \r\n// in smaller methods (except if they are automatically generated by a tool).\r\n// See the definition of the CyclomaticComplexity metric here http://www.ndepend.com/Metrics.aspx#CC</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (ILCyclomaticComplexity)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE ILCyclomaticComplexity &gt; 40 ORDER BY ILCyclomaticComplexity DESC\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 20 are hard to understand and maintain.\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 40 are extremely complex and should be split \r\n// in smaller methods (except if they are automatically generated by a tool).\r\n// See the definition of the ILCyclomaticComplexity metric here http://www.ndepend.com/Metrics.aspx#ILCC</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (ILNestingDepth)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE ILNestingDepth &gt; 4 ORDER BY ILNestingDepth DESC\r\n// METHODS WHERE ILNestingDepth &gt; 4 are hard to understand and maintain. \r\n// METHODS WHERE ILNestingDepth &gt; 8 is higher than 8 are extremely complex and should be split in smaller methods \r\n// (except if they are automatically generated by a tool). \r\n// See the definition of the NbILInstructions metric here http://www.NDepend.com/Metrics.aspx#ILNestingDepth</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many parameters (NbParameters)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbParameters &gt; 5 ORDER BY NbParameters DESC\r\n// METHODS WHERE NbParameters &gt; 5 might be painful to call and might degrade performance. \r\n// You should prefer using additional properties/fields to the declaring type to handle \r\n// numerous states. Another alternative is to provide a class or structure dedicated to \r\n// handle arguments passing (for example see the class System.Diagnostics.ProcessStartInfo \r\n// and the method System.Diagnostics.Process.Start(ProcessStartInfo))\r\n// See the definition of the NbParameters metric here http://www.ndepend.com/Metrics.aspx#NbParameters</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many local variables (NbVariables)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbVariables &gt; 15 ORDER BY NbVariables DESC\r\n// METHODS WHERE NbVariables &gt; 8 are hard to understand and maintain.\r\n// METHODS WHERE NbVariables &gt; 15 are extremely complex and should be split in \r\n// smaller methods (except if they are automatically generated by a tool).\r\n// See the definition of the Nbvariables metric here http://www.ndepend.com/Metrics.aspx#Nbvariables</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many overloads (NbOverloads)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbOverloads &gt; 6 ORDER BY NbOverloads DESC\r\n// METHODS WHERE NbParameters &gt; 6 might be a problem to maintain and provoke higher coupling than necessary. \r\n// This might also reveal a potential misused of the C# and VB.NET language that since C#3 and VB9 support \r\n// object initialization. This feature helps reducing the number of constructors of a class.\r\n// See the definition of the NbOverloads metric here http://www.ndepend.com/Metrics.aspx#NbOverloads</CQLQuery>
      <CQLGroup Name="Type Metrics" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with too many methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE NbMethods &gt; 20 ORDER BY NbMethods DESC\r\n// TYPES WHERE NbMethods &gt; 20 might be hard to understand and maintain \r\n// but there might be cases where it is relevant to have a high value for NbMethods. \r\n// For example, the System.Windows.Forms.DataGridView standard class has more than 1000 methods.\r\n// See the definition of the NbMethods metric here http://www.ndepend.com/Metrics.aspx#NbMethods</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with too many fields&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE NbFields &gt; 20 AND !IsEnumeration ORDER BY NbFields DESC\r\n// TYPES WHERE NbFields &gt; 20 AND !IsEnumeration might be hard to understand and maintain \r\n// but there might be cases where it is relevant to have a high value for NbFields. \r\n// For example, the System.Windows.Forms.Control standard class has more than 200 fields. \r\n// The value of the metric NbFields might be a better indicator of complex type.\r\n// See the definition of the NbFields metric here http://www.ndepend.com/Metrics.aspx#NbFields</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with poor cohesion (LCOM)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10 ORDER BY LCOM DESC\r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10 might be problematic. \r\n// However, it is very hard to avoid such non-cohesive types. The LCOMHS metric\r\n// is often considered as more efficient to detect non-cohesive types.\r\n// See the definition of the LCOM metric here http://www.ndepend.com/Metrics.aspx#LCOM</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with poor cohesion (LCOMHS)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE LCOMHS &gt; 0.95 AND NbFields &gt; 10 AND NbMethods &gt;10 ORDER BY LCOMHS DESC\r\n// TYPES WHERE LCOMHS &gt; 1.0 AND NbFields &gt; 10 AND NbMethods &gt;10 should be avoided. \r\n// Note that this constraint is stronger than the constraint \r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10. \r\n// See the definition of the LCOMHS metric here http://www.ndepend.com/Metrics.aspx#LCOMHS</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Design" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assembly should not contain namespaces dependency cycles&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 ASSEMBLIES WHERE ContainsNamespaceDependencyCycle\r\n// Dependency cycles between namespaces must be avoided \r\n// in order to have a levelized and comprehensive design.\r\n// More info available on the screencast 'Reduce the complexity' http://s3.amazonaws.com/NDependOnlineDemos/NDependReducingComplexity_viewlet_swf.html\r\n// You can also read this article http://www.theserverside.net/tt/articles/showarticle.tss?id=ControllingDependencies</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Type should not have too many responsabilities (Efferent Coupling)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE TypeCe &gt; 50 ORDER BY TypeCe DESC \r\n// The Efferent Coupling (TypeCe) for a particular type is the number of types \r\n// it directly depends on. Notice that types declared in tier assemblies are taken into account. \r\n\r\n// Types that depends on too many others type (more than 50) are complex and have\r\n// more than one responsability. They are good candidate for refactoring.\r\n\r\n// More information available in this article:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/02/15/code-metrics-on-coupling-dead-code-design-flaws-and-re-engineering.aspx\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid namespaces with few types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 NAMESPACES WHERE NbTypes &lt; 5 ORDER BY NbTypes ASC \r\n\r\n// Make sure that there is a logical organization to each of your namespaces, \r\n// and that there is a valid reason for putting types in a sparsely populated \r\n// namespace. Namespaces should contain types that are used together in most \r\n// scenarios. When their applications are mutually exclusive, types should be \r\n// located in separate namespaces</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Declare types in namespaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE NameIs "" AND !IsInFrameworkAssembly \r\n\r\n// Types are declared within namespaces to prevent name collisions, and as a way of organizing related types \r\n// in an object hierarchy. Types outside any named namespace are in a global namespace that cannot be referenced in code.\r\n// If an anonymous namespace can be found, it means that it contains types outside of namespaces.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assemblies with poor cohesion (RelationalCohesion)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 ASSEMBLIES WHERE RelationalCohesion &lt; 1.5 OR RelationalCohesion &gt; 4.0\r\n\r\n// As classes inside an assembly should be strongly related, \r\n// the cohesion should be high. On the other hand, a value which is too high may \r\n// indicate over-coupling. A good range for RelationalCohesion is 1.5 to 4.0.\r\n// See the definition of the RelationalCohesion metric here http://www.ndepend.com/Metrics.aspx#RelationalCohesion</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assemblies that don't satisfy the Abstractness/Instability principle&lt;/Name&gt;\r\n\r\nWARN IF Percentage &gt; 15 IN SELECT ASSEMBLIES WHERE NormDistFromMainSeq &gt; 0.7 ORDER BY NormDistFromMainSeq DESC\r\n\r\n// See the definition of the NormDistFromMainSeq metric here http://www.ndepend.com/Metrics.aspx#DitFromMainSeq</CQLQuery>
      <CQLGroup Name="Performance" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Instances size shouldn't be too big (SizeOfInst)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE SizeOfInst &gt; 64 ORDER BY SizeOfInst DESC\r\n// TYPES WHERE SizeOfInst &gt; 64 might degrade performance (depending on the number of \r\n// instances created at runtime) and might be hard to maintain. \r\n// However it is not a rule since sometime there is no alternative \r\n// (the size of instances of the System.Net.NetworkInformation.SystemIcmpV6Statistics \r\n// standard class is 2064 bytes).\r\n// See the definition of the SizeOfInst metric here http://www.ndepend.com/Metrics.aspx#SizeOfInst</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Boxing/unboxing should be avoided (Method)&lt;/Name&gt;\r\nWARN IF Percentage &gt; 5 IN SELECT METHODS WHERE IsUsingBoxing OR IsUsingUnboxing \r\n// Thanks to generics, boxing and unboxing should be rare.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Boxing/unboxing should be avoided (Type)&lt;/Name&gt;\r\nWARN IF Percentage &gt; 5 IN SELECT TYPES WHERE IsUsingBoxing OR IsUsingUnboxing \r\n// Thanks to generics, boxing and unboxing should be rare.</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Attribute classes should be sealed&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE IsAttributeClass \r\nAND !IsSealed AND !IsAbstract AND IsPublic AND !IsInFrameworkAssembly \r\n\r\n// The .NET Framework class library provides methods for retrieving custom attributes. \r\n// By default, these methods search the attribute inheritance hierarchy; for example \r\n// System.Attribute.GetCustomAttribute searches for the specified attribute type, or \r\n// any attribute type that extends the specified attribute type. Sealing the attribute \r\n// eliminates the search through the inheritance hierarchy, and can improve performance.</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Unused Code / Dead Code" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n MethodCa == 0 AND            // Ca=0 -&gt; No Afferent Coupling -&gt; The method is not used in the context of this application.\r\n !IsPublic AND                // Public methods might be used by client applications of your assemblies.\r\n !IsEntryPoint AND            // Main() method is not used by-design.\r\n !IsExplicitInterfaceImpl AND // The IL code never explicitely calls explicit interface methods implementation.\r\n !IsClassConstructor AND      // The IL code never explicitely calls class constructors.\r\n !IsFinalizer                 // The IL code never explicitely calls finalizers.\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused fields&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n FieldCa == 0 AND  // Ca=0 -&gt; No Afferent Coupling -&gt; The field is not used in the context of this application.\r\n !IsPublic AND     // Although not recommended, public fields might be used by client applications of your assemblies.\r\n !IsLiteral AND    // The IL code never explicitely uses literal fields.\r\n !IsEnumValue AND  // The IL code never explicitely uses enumeration value.\r\n !NameIs "value__" // Field named 'value__' are relative to enumerations and the IL code never explicitely uses them.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n TypeCa == 0 AND     // Ca=0 -&gt; No Afferent Coupling -&gt; The type is not used in the context of this application.\r\n !IsPublic AND       // Public types might be used by client applications of your assemblies.\r\n !NameIs "Program"   // Generally, types named Program contain a Main() entry-point method and this condition avoid to consider such type as unused code.\r\n</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Encapsulation" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields should be declared as private&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n !IsPrivate AND \r\n // These conditions filter cases where fields doesn't represent state that should be encapsulated. \r\n !IsInFrameworkAssembly AND \r\n !IsGeneratedByCompiler AND \r\n !IsSpecialName AND \r\n !IsInitOnly AND \r\n !IsLiteral AND \r\n !IsEnumValue</CQLQuery>
      <CQLGroup Name="Fields Optimal Encapsulation" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE CouldBePrivate</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT FIELDS WHERE ShouldBePublic \r\n// The keyword 'ShouldBePublic' shows code elements declared as 'internal\Friend' that are used outside of their assembly\r\n// thanks to the Attribute System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Diff / Changes / Evolution" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS\r\nWHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)\r\n\r\n// This constraint warns if a public method is not public anymore or if it has been removed.\r\n// This can break the code of your clients.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES\r\nWHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)\r\n\r\n// This constraint warns if a public type is not public anymore or if it has been removed.\r\n// This can break the code of your clients.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Interfaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES\r\nWHERE IsInterface AND IsPublic AND (WasChanged AND !CommentsWereChanged)\r\n\r\n// This constraint warns if a public interface has been changed, but not because of comment change.\r\n// This can break the code of your clients that implements such interface.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison</CQLQuery>
      <CQLGroup Name="Changes Summary" Active="False">
        <CQLGroup Name="Methods" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods added&lt;/Name&gt;\r\nSELECT METHODS WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods removed&lt;/Name&gt;\r\nSELECT METHODS WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where code was changed&lt;/Name&gt;\r\nSELECT METHODS WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where comments were changed&lt;/Name&gt;\r\nSELECT METHODS WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where visibility was changed&lt;/Name&gt;\r\nSELECT METHODS WHERE VisibilityWasChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods that became obsolete&lt;/Name&gt;\r\nSELECT METHODS WHERE BecameObsolete  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Fields" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Fields added&lt;/Name&gt;\r\nSELECT FIELDS WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Fields removed&lt;/Name&gt;\r\nSELECT FIELDS WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Types" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types added&lt;/Name&gt;\r\nSELECT TYPES WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types removed&lt;/Name&gt;\r\nSELECT TYPES WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where code was changed&lt;/Name&gt;\r\nSELECT TYPES WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where comments were changed&lt;/Name&gt;\r\nSELECT TYPES WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where visibility was changed&lt;/Name&gt;\r\nSELECT TYPES WHERE VisibilityWasChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tyoes that became obsolete&lt;/Name&gt;\r\nSELECT TYPES WHERE BecameObsolete  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Namespaces" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces added&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces removed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces where code was changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces where comments were changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Assemblies" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies added&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies removed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies where code was changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies where comments were changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Tier Code Usage" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Methods that were not used and that are now used&lt;/Name&gt;\r\nSELECT METHODS WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Methods that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT METHODS WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types that were not used and that are now used&lt;/Name&gt;\r\nSELECT TYPES WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT TYPES WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types where usage changed&lt;/Name&gt;\r\nSELECT TYPES WHERE IsUsedDifferently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces that were not used and that are now used&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces where usage changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsUsedDifferently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies that were not used and that are now used&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies where usage changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsUsedDifferently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Fields that were not used and that are now used&lt;/Name&gt;\r\nSELECT FIELDS WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Fields that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT FIELDS WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
        </CQLGroup>
      </CQLGroup>
      <CQLGroup Name="Test Coverage of Changes Summary" Active="False">
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed 100% covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 100 AND CodeWasChanged ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added 100% covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE WasAdded AND PercentageCoverage == 100 ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed partially covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &lt; 100 AND PercentageCoverage &gt; 0 AND\r\n  CodeWasChanged \r\n  ORDER BY PercentageCoverage DESC , NbLinesOfCodeCovered , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added partially covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &lt; 100 AND PercentageCoverage &gt; 0 AND\r\n  WasAdded  \r\n  ORDER BY PercentageCoverage DESC , NbLinesOfCodeCovered , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed not covered at all&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 0 AND CodeWasChanged ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added not covered at all&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 0 AND WasAdded ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Purity / Immutability / Side-Effects" Active="True">
      <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields should be marked as ReadOnly when possible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE IsImmutable AND !IsInitOnly\r\n\r\n// A field that matches the condition IsImmutable is a field that is assigned only by constructors of its class.\r\n// For an instance field, this means its value will remain constant throught the lifetime of the object.\r\n// For a static field, this means its value will remain constant throught the lifetime of the program.\r\n// In both cases, such field can safely be marked with the C# readonly keyword (ReadOnly in VB.NET).\r\n\r\n// The condition IsInitOnly matches fields that are marked with the C# readonly keyword (ReadOnly in VB.NET).\r\n\r\n\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Structures should be immutable&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE IsStructure AND !IsImmutable AND !IsInFrameworkAssembly\r\n\r\n// It is deemed as a good practice to make your structure immutable.\r\n// An object is immutable if its state doesn’t change once the object has been created. \r\n// Consequently, a structure is immutable if its instances are immutable.\r\n// Immutable types naturally simplify code by limiting side-effects.\r\n// See some explanations on immutability and how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Regression on immutable types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND !IsImmutable\r\n\r\n// An object is immutable if its state doesn’t change once the object has been created. \r\n// Consequently, a class or a structure is immutable if its instances are immutable.\r\n// Immutable types naturally simplify code by limiting side-effects.\r\n// See some explanations on immutability and how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n\r\n// NDepend.CQL.ImmutableAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'immutable' types.\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Regression on pure methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND \r\n  ( ChangesObjectState OR ChangesTypeState ) AND\r\n  NbLinesOfCode &gt; 0\r\n\r\n// A method is pure if its execution doesn’t change the value of any instance or static field. \r\n// Pure methods naturally simplify code by limiting side-effects.\r\n// See some explanations on immutability / purity and how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n\r\n// NDepend.CQL.PureAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'pure' methods.\r\n\r\n</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Naming Conventions" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Instance fields should be prefixed with a '_'&lt;/Name&gt;
WARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE 
  !NameLike "^_" AND 
  !IsStatic AND 
  !IsLiteral AND 
  !IsGeneratedByCompiler  AND 
  !IsSpecialName AND 
  !IsEventDelegateObject 

// This naming convention provokes debate.
// Don't hesitate to customize the regex of NameLike to your preference.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Static fields should be prefixed with a '_'&lt;/Name&gt;
WARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE 
  !NameLike "^_" AND 
  IsStatic AND 
  !IsLiteral AND 
  !IsGeneratedByCompiler AND 
  !IsSpecialName AND 
  !IsEventDelegateObject  

// This naming convention provokes debate.
// Don't hesitate to customize the regex of NameLike to your preference.
</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Interface name should begin with a 'I'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsInterface AND !NameLike "^I" AND !IsNested AND !IsInFrameworkAssembly\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Abstract base class should be suffixed with 'Base'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsAbstract AND \r\n  IsClass AND\r\n  DepthOfInheritance == 1 AND // equivalent to:   DepthOfDeriveFrom "System.Object" == 1\r\n  !NameLike "Base$"\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Exception class name should be suffixed with 'Exception'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsExceptionClass AND !NameLike "Exception$" AND !IsInFrameworkAssembly\r\n// The name of an exception class should end with 'Exception'.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Attribute class name should be suffixed with 'Attribute'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsAttributeClass AND !NameLike "Attribute$" AND !IsInFrameworkAssembly\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types name should begin with an Upper character&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n !NameLike "^[A-Z]" AND     // The name of a type should begin with an Upper letter.\r\n !IsGeneratedByCompiler AND // Except if it is generated by compiler or ...\r\n !IsInFrameworkAssembly     // ... if it is declared in a framework assembly.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods name should begin with an Upper character&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n !NameLike "^[A-Z]" AND \r\n !(IsClassConstructor OR IsConstructor OR \r\n IsPropertyGetter  OR IsPropertySetter OR\r\n IsIndexerGetter OR IsIndexerSetter OR\r\n IsEventAdder OR IsEventRemover OR\r\n IsOperator) AND !IsGeneratedByCompiler AND !IsInFrameworkAssembly\r\n// The name of a regular method should begin with an Upper letter.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not name enum values 'Reserved'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE IsEnumValue AND NameLike "Reserved"\r\n\r\n// This rule assumes that an enumeration member with a name that contains "reserved" \r\n// is not currently used but is a placeholder to be renamed or removed in a future version.\r\n// Renaming or removing a member is a breaking change. You should not expect users to ignore\r\n// a member just because its name contains "reserved" nor can you rely on users to read or \r\n// abide by documentation. Furthermore, because reserved members appear in object browsers \r\n// and smart integrated development environments, they can cause confusion as to which members \r\n// are actually being used.\r\n\r\n// Instead of using a reserved member, add a new member to the enumeration in the future version.\r\n// In most cases, the addition of the new member is not a breaking change, as long as the \r\n// addition does not cause the values of the original members to change.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Type names should not match namespaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  NameIs "Collections" OR\r\n  NameIs "Forms" OR\r\n  NameIs "System" OR\r\n  NameIs "UI"\r\n\r\n// Type names should not match the names of namespaces defined in the .NET Framework \r\n// class library. Violating this rule can reduce the usability of the library.</CQLQuery>
    </CQLGroup>
    <CQLGroup Name=".NET Framework Usage" Active="True">
      <CQLGroup Name="System" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark ISerializable types with serializable&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n IsPublic AND !IsDelegate AND\r\n Implement "OPTIONAL:System.Runtime.Serialization.ISerializable" AND \r\n !HasAttribute "OPTIONAL:System.SerializableAttribute"\r\n\r\n// To be recognized by the CLR as serializable, types must be marked with the SerializableAttribute \r\n// attribute even if the type uses a custom serialization routine through implementation of the ISerializable interface.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with ComVisible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.Runtime.InteropServices.ComVisibleAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The ComVisibleAttribute attribute determines how COM clients access managed code. \r\n// Good design dictates that assemblies explicitly indicate COM visibility. \r\n// COM visibility can be set for an entire assembly and then overridden for individual \r\n// types and type members. If the attribute is not present, the contents of the assembly\r\n// are visible to COM clients.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark attributes with AttributeUsageAttribute&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nDeriveFrom "OPTIONAL:System.Attribute" AND\r\n!HasAttribute "OPTIONAL:System.AttributeUsageAttribute" AND\r\n!IsInFrameworkAssembly \r\n\r\n// When defining a custom attribute, mark it using AttributeUsageAttribute to \r\n// indicate where in the source code the custom attribute can be applied.\r\n// An attribute's meaning and intended usage will determine its valid locations \r\n// in code. For example, if you are defining an attribute that identifies the \r\n// person responsible for maintaining and enhancing each type in a library, \r\n// and responsibility is always assigned at the type level, compilers should \r\n// allow the attribute on classes, enumerations, and interfaces, but should \r\n// not allow it on methods, events, or properties. Organizational policies and\r\n// procedures would dictate whether the attribute should be allowed on assemblies.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Remove calls to GC.Collect()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)"\r\n\r\n// It is preferrable to avoid calling GC.Collect() explicitely\r\n// in order to avoid some performance pitfall.\r\n// More in information on this here:\r\n// http://blogs.msdn.com/ricom/archive/2004/11/29/271829.aspx</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't call GC.Collect() without calling GC.WaitForPendingFinalizers()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  (IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR\r\n   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)") \r\n  AND\r\n  !IsDirectlyUsing "OPTIONAL:System.GC.WaitForPendingFinalizers()" \r\n\r\n// It is preferrable to avoid calling GC.Collect() explicitely\r\n// in order to avoid some performance pitfall.\r\n// But if you wish to call GC.Collect(), you must do it this way:\r\n//   GC.Collect();\r\n//   GC.WaitForPendingFinalizers();\r\n//   GC.Collect();\r\n// To make sure that finalizer got executed, and object with finalizer got cleaned properly.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Enum Storage should be Int32&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  NameIs "value__" AND \r\n  !IsOfType "OPTIONAL:System.Int32" AND\r\n  !IsInFrameworkAssembly\r\n\r\n// An enumeration is a value type that defines a set of related named constants. By default, \r\n// the System.Int32 data type is used to store the constant value. Even though you can change \r\n// this underlying type, it is not necessary or recommended for most scenarios. Note that there \r\n// is no significant performance gain in using a data type smaller than Int32. If you cannot \r\n// use the default data type, you should use one of the CLS-compliant integral types, Byte, \r\n// Int16, Int32, or Int64, to ensure that all of the enumeration's values are representable in \r\n// CLS-compliant programming languages.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not raise reserved exception types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  // The following exception types are reserved and should be thrown only by the Common Language Runtime:\r\n  ( DepthOfCreateA "OPTIONAL:System.ExecutionEngineException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.IndexOutOfRangeException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.NullReferenceException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.OutOfMemoryException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.StackOverflowException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.InvalidProgramException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.AccessViolationException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.CannotUnloadAppDomainException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.BadImageFormatException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.DataMisalignedException" == 1 )\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Use integral or string argument for indexers&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\nIsIndexerGetter AND \r\n !( NameIs "get_Item(String)" OR \r\n    NameLike "get_Item\(Int" OR \r\n    NameLike "get_Item\(Byte" OR\r\n    NameLike "get_Item\(SByte" )\r\n\r\n// Indexers, that is, indexed properties, should use integer or string types for the index. \r\n// These types are typically used for indexing data structures and increase the usability of \r\n// the library. Use of the Object type should be restricted to those cases where the specific \r\n// integer or string type cannot be specified at design time. If the design requires other \r\n// types for the index, reconsider whether the type represents a logical data store. If it \r\n// does not represent a logical data store, use a method.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Uri fields should be of type System.Uri&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  (NameLike "Uri$" OR NameLike "Url$") AND !IsOfType "OPTIONAL:System.Uri"\r\n\r\n// A field which name end with 'Uri' is deemed as representing a uri.\r\n// Such field should be of type System.Uri.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types should not extend System.ApplicationException&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE\r\n  DepthOfDeriveFrom "OPTIONAL:System.ApplicationException" == 1 AND\r\n  !IsInFrameworkAssembly\r\n\r\n// For .NET Framework version 1, it was recommended to derive new exceptions from ApplicationException. \r\n// The recommendation has changed and new exceptions should derive from System.Exception or one of its \r\n// subclasses in the System namespace.</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Runtime.InteropServices" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;P/Invokes should be static and not be visible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  !IsInFrameworkAssembly AND\r\n  (HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute") AND\r\n  ( IsPublic OR \r\n    !IsStatic)\r\n\r\n// Methods marked with the DllImportAttribute attribute (or methods defined using the \r\n// Declare keyword in Visual Basic) use Platform Invocation Services to access unmanaged \r\n// code. Such methods should not be exposed. Keeping these methods private or internal \r\n// ensures that your library cannot be used to breach security by allowing callers access \r\n// to unmanaged APIs they could not call otherwise.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Move P/Invokes to NativeMethods class&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  !IsInFrameworkAssembly AND\r\n  HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute" AND\r\n  !FullNameLike "NativeMethods."\r\n\r\n// Platform Invocation methods, such as those marked with the System.Runtime.InteropServices.DllImportAttribute \r\n// attribute, or methods defined by using the Declare keyword in Visual Basic, access unmanaged code. \r\n// These methods should be in one of the following classes:\r\n//\r\n//     - NativeMethods - This class does not suppress stack walks for unmanaged code permission. \r\n//       (System.Security.SuppressUnmanagedCodeSecurityAttribute must not be applied to this class.) \r\n//       This class is for methods that can be used anywhere because a stack walk will be performed.\r\n//\r\n//     - SafeNativeMethods - This class suppresses stack walks for unmanaged code permission. \r\n//       (System.Security.SuppressUnmanagedCodeSecurityAttribute is applied to this class.) \r\n//       This class is for methods that are safe for anyone to call. Callers of these methods are not \r\n//       required to do a full security review to ensure that the usage is secure because the methods\r\n//       are harmless for any caller.\r\n//\r\n//     - UnsafeNativeMethods - This class suppresses stack walks for unmanaged code permission. \r\n//       (System.Security.SuppressUnmanagedCodeSecurityAttribute is applied to this class.) \r\n//       This class is for methods that are potentially dangerous. Any caller of these methods must do\r\n//       a full security review to ensure that the usage is secure because no stack walk will be performed.\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;NativeMethods class should be static and internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE\r\n  !IsInFrameworkAssembly AND\r\n  ( NameIs "NativeMethods" OR\r\n    NameIs "SafeNativeMethods" OR\r\n    NameIs "UnsafeNativeMethods") AND\r\n  IsPublic OR\r\n  !IsStatic \r\n\r\n// Native Methods' classes are declared as internal (Friend, in Visual Basic) and static.\r\n</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Xml" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Method should not return concrete XmlNode&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n( ReturnTypeIs "OPTIONAL:System.Xml.XmlDocument" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlAttribute" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlDocumentFragment" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlEntity" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlLinkedNode" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlNotation" OR\r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlNode" )\r\n\r\n// The class System.Xml.XmlNode implements the interface System.Xml.Xpath.IXPathNavigable.\r\n// It is preferrable to return this interface instead of a concrete class.\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types should not extend System.Xml.XmlDocument&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE DepthOfDeriveFrom "OPTIONAL:System.Xml.XmlDocument" == 1\r\n\r\n// Do not create a subclass of XmlDocument if you want to create an XML view of an underlying object model or data source.</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Statistics" Active="False">
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used types (TypeRank)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeRank DESC\r\n// TypeRank values are computed by applying the Google PageRank \r\n// algorithm on the graph of types' dependencies \r\n// Types with high Rank are the most used ones.\r\n// See the definition of the TypeRank metric here http://www.ndepend.com/Metrics.aspx#TypeRank</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used methods (MethodRank)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodRank DESC\r\n// MethodRank values are computed by applying the Google PageRank \r\n// algorithm on the graph of methods' dependencies\r\n// Methods with high Rank are the most used ones.\r\n// See the definition of the MethodRank metric here http://www.ndepend.com/Metrics.aspx#MethodRank</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used namespaces (NamespaceCa)&lt;/Name&gt;\r\nSELECT TOP 50 NAMESPACES ORDER BY NamespaceCa DESC\r\n// The Afferent Coupling for a particular namespace is the number of namespaces that depends directly on it.\r\n// Namespaces with high Ca are the most used ones.\r\n// See the definition of the NamespaceCa metric here http://www.ndepend.com/Metrics.aspx#NamespaceCa</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used types  (TypeCa)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeCa DESC\r\n// The Afferent Coupling for a particular type is the number of types that depends directly on it.\r\n// Types with high Ca are the most used ones.\r\n// See the definition of the TypeCa metric here http://www.ndepend.com/Metrics.aspx#TypeCa</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used methods (MethodCa)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodCa DESC\r\n// The Afferent Coupling for a particular method is the number of methods that depends directly on it.\r\n// Methods with high Ca are the most used ones\r\n// See the definition of the MethodCa metric here http://www.ndepend.com/Metrics.aspx#MethodCa</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces that use many other namespaces (NamespaceCe)&lt;/Name&gt;\r\nSELECT TOP 50 NAMESPACES ORDER BY NamespaceCe DESC\r\n// The Efferent Coupling for a particular namespace is the number of namespaces it directly depends on.\r\n// Namespaces declared in Framework assemblies are taken account.\r\n// See the definition of the NamespaceCe metric here http://www.ndepend.com/Metrics.aspx#NamespaceCe</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types that use many other types (TypeCe)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeCe DESC\r\n// The Efferent Coupling for a particular type is the number of types it directly depends on.\r\n// Types declared in Framework assemblies are taken account.\r\n// See the definition of the TypeCe metric here http://www.ndepend.com/Metrics.aspx#TypeCe</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods that use many other methods (MethodCe)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodCe DESC\r\n// The Efferent Coupling for a particular method is the number of methods it directly depends on.\r\n// Methods declared in Framework assemblies are taken account.\r\n// See the definition of the MethodCe metric here http://www.ndepend.com/Metrics.aspx#MethodCe</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level assemblies (AssemblyLevel)&lt;/Name&gt;\r\nSELECT ASSEMBLIES ORDER BY AssemblyLevel DESC\r\n// Classify assemblies by their Level values.\r\n// See the definition of the AssemblyLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level namespaces (NamespaceLevel)&lt;/Name&gt;\r\nSELECT NAMESPACES ORDER BY NamespaceLevel DESC\r\n// Classify namespaces by their Level values.\r\n// See the definition of the NamespaceLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level types (TypeLevel)&lt;/Name&gt;\r\nSELECT TYPES ORDER BY TypeLevel DESC\r\n// Classify types by their Level values.\r\n// See the definition of the TypeLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level methods (MethodLevel)&lt;/Name&gt;\r\nSELECT METHODS ORDER BY MethodLevel DESC\r\n// Classify methods by their Level values.\r\n// See the definition of the MethodLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
    </CQLGroup>
  </CQLQueries>
</NDepend>